package com.company;

import java.util.Stack;

public class MyBinary {
    /**
     * массив целочисленных положительных значений степени двойки
     * для сравнения с числовым рядом, и быстрого поиска показателя степени
     * индекс массива = степень
     * значение массива = значение "два в степени"
     */
    static final int[] PowerNumTwo = new int[]{
            1,
            2,
            4,
            8,
            16,
            32,
            64,
            128,
            256,
            512,
            1024,
            2048,
            4096,
            8192,
            16384,
            32768,
            65536,
            131072,
            262144,
            524288,
            1048576,
            2097152,
            4194304,
            8388608,
            16777216,
            33554432,
            67108864,
            134217728,
            268435456,
            536870912,
            1073741824,
            2147483647
    };

    /**
     * Функция перевода в двоичную форму использующая алгоритм с последовательным делением на 2
     * Можно вернуть как строку бит или массив. Сейчас возвращается строка.
     * @param numDec заданное число которое мы переводим в двоичную форму
     * @return строка с числом в двоичной форме
     */
    public static String binaryConversion(int numDec){
        Stack stack = new Stack();
        String strBinary = "";

        /**
         * цикл для перевода в двоичную форму в виде строки
         */
        for (int i = numDec; i >= 1; i = i / 2) {
            int stageValue = i % 2;
            stack.push(stageValue);
            strBinary = stageValue + strBinary;
        }

        /**
         * можно вернуть как массив бит
         */
        int m = stack.size();
        int[] resultArray = new int[m];

        /**
         * цикл для переворота массива
         */
        for (int n = 0; n < m; n++) {
            resultArray[n] = (int) stack.pop();
        }

        return strBinary;
    }

    /**
     * Функция для определения значения и показателя степени ближайшего к заданному, на каждом этапе перевода, значению х
     * используется цикл для смещения бита в двоичной форме показателя степени
     * t - установка старшего бита определяющего показатель степени для целочисленного значения степени
     * @param x заданное число которое мы переводим в двоичную форму
     * @param i показатель степени для этапа перевода (при первом вызове i=30)
     * @param t значение степени 2^i для этапа перевода (при первом вызове t=0)
     * @return массив arrMyBin1 с найденными показателем i и значением степени t
     */
    private static int[] myBin1(int x, int i, int t) {
        int[] arrMyBin1 = new int[2];
        t = 1 << i;     // определение положения старшего бита и всей длины (при первом вызове) итогового двоичного числа
        while (x < t) {
            t >>= 1;
            i -= 1;
        }
        arrMyBin1[0] = i;
        arrMyBin1[1] = t;
        return arrMyBin1;
    }

    /**
     * Функция для двоичной формы в виде строки
     * вспомогательные функции не используются
     * @param x заданное число которое мы переводим в двоичную форму
     * @return строка с числом в двоичной форме
     */
    public static String myBinString2(int x) {
        int i = PowerNumTwo.length - 1;
        String strMyBin2 = "";
        int y = x;  // y - меняется в процессе перевода

        if (x != 0) {
            for (int k = i; k >= 0; k--) {
                if (y >= PowerNumTwo[k]) {
                    strMyBin2 += "1";
                    y = y - PowerNumTwo[k];
                } else if (x == y) continue;    // чтобы пропустить незначащие нули в начале двоичной формы
                  else strMyBin2 += "0";
            }
        } else strMyBin2 = "0";

        return strMyBin2;
    }

    /**
     * Функция для переворачивания массива с двоичной формой
     */
    private static int[] reverse(int[] arr) {
        int cycleSize;
        int m = arr.length - 1;

        if ((arr.length % 2) == 0) {
            cycleSize = arr.length / 2;
        } else {
            cycleSize = (arr.length - 1) / 2;
        }

        for (int index = 0; index < cycleSize; index++) {
            arr[index] = arr[index] ^ arr[(m - index)];
            arr[(m - index)] = arr[index] ^ arr[m - index];
            arr[index] = arr[m - index] ^ arr[index];
        }

        return arr;
    }

    /**
     * Функция перевода в двоичную форму использующая смещение старшего бита для вычисления степени ближайшей к искомому х
     * для перебора значений используется вспомогательная функция
     * (int)1 073 741 824 = 2^30 => (bin)100 0000 0000 0000 0000 0000 0000 0000
     * @param x заданное число которое мы переводим в двоичную форму
     * @return возвращается массив бит дающий заданное число х в двоичной форме
     */
    public static int[] myBinArr(int x) {
        int i = 30;     // магическое число - степень для препоследнего числа перед максимальным для int
        int t = 0;
        int[] arrMyBin;
        if (x > 0) {
            /**
             * первый вызов для определения всей длины двоичного числа и установки первого бита в нем
             */
            int[] a1 = myBin1(x, i, t);
            arrMyBin = new int[a1[0] + 1];

            /**
             * вызов в цикле для определения значения следующих бит числа
             */
            while (x > 0) {
                arrMyBin[a1[0]] = 1;
                x = x - a1[1];
                a1 = myBin1(x, a1[0], a1[1]);
            }
        } else {
            arrMyBin = new int[1];      // для случая когда х=0 используется значение массива при инициализации по-умолчанию=0
        }

        return reverse(arrMyBin);
    }

    /**
     * Вспомогательная функция для поиска показателя степени дающего число ближайшее меньшее искомого на каждом шаге алгоритма перевода
     * @param x число для сравнения с рядом степеней на каждом шаге алгоритма
     * @param i показатель степени для этапа перевода - индекс для числа в массиве степеней двойки
     * @return возвращается показатель степени (индекс в массиве) дающий число ближайшее к заданному на шаге алгоритма
     */
    private static int myBin2(int x, int i) {

        while ((i >= 0) && (x < PowerNumTwo[i])) {
            --i;
        }

        return i;
    }

    /**
     * Функция для перевода числа х в двоичную форму использующая заранее рассчитанных массив значений
     * используется вспомогательная функция
     * @param x заданное число которое мы переводим в двоичную форму
     * @return возвращается массив бит дающий заданное число х в двоичной форме
     */
    public static int[] myBinArr2(int x) {
        int arrLenght = PowerNumTwo.length - 1;
        int a2;
        int[] arrMyBin2;

        if (x <= 0) {
            a2 = 0;
        } else {
            a2 = myBin2(x, arrLenght);  // первый вызов для определения всей длины двоичного числа и установки первого бита в нем
        }

        arrMyBin2 = new int[a2+1];

        /**
         * вызов в цикле для определения значения следующих бит числа
         */
        while ((a2 >= 0) && (x > 0)) {
            arrMyBin2[a2] = 1;
            x = x - PowerNumTwo[a2];
            int ii = a2 - 1;
            a2 = myBin2(x, ii);
        }

        return reverse(arrMyBin2);
    }
}

